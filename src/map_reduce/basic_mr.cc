#include <algorithm>
#include <fstream>
#include <iostream>
#include <sstream>
#include <string>
#include <vector>

#include "map_reduce/protocol.h"

namespace mapReduce {
//
// The map function is called once for each file of input. The first
// argument is the name of the input file, and the second is the
// file's complete contents. You should ignore the input file name,
// and look only at the contents argument. The return value is a slice
// of key/value pairs.
//
    bool CharMatch(const char ch) {
        if ((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z')) {
            return true;
        }
        return false;
    }

    std::map<std::string, int> CountMap(const std::string &content) {
        auto punctuation_free_content = std::string();
        punctuation_free_content.resize(content.size());
        std::transform(content.begin(), content.end(), punctuation_free_content.begin(), [](const char ch) {
            if (CharMatch(ch)) {
                return ch;
            }
            return ' ';
        });
        while (!CharMatch(punctuation_free_content.back())) {
            punctuation_free_content.pop_back();
        }
        // count words
        auto ss = std::stringstream(punctuation_free_content);
        auto word = std::string();
        auto count_map = std::map<std::string, int>{};
        while (!ss.eof()) {
            ss >> word;
            count_map[word]++;
        }
        return count_map;
    }

    std::vector<uint8_t> SerializeCountMap(const std::map<std::string, int> &count_map) {
        std::stringstream ss;
        for (const auto &[key, value] : count_map) {
            ss << key << " " << value << "\n";
        }
        std::string content = ss.str();
        return std::vector<uint8_t>{content.begin(), content.end()};
    }

    void DeserializeCountMap(const std::vector<uint8_t> &content, std::map<std::string, int> &count_map) {
        std::string str_content(content.begin(), content.end());
        std::stringstream ss(str_content);
        std::string word;
        int count;
        while (!ss.eof()) {
            ss >> word >> count;
            if (word.front() == '\0') {
                continue;
            }
            count_map[word] += count;

            //    LOG_FORMAT_INFO("{} {}", word, count_map[word]);
        }
    }

    std::vector<KeyVal> Map(const std::string &content) {
        // Your code goes here
        // Hints: split contents into an array of words.

        // transform to punctuation-free words.
        auto count_map = CountMap(content);
        // prepare return value
        std::vector<KeyVal> ret;
        ret.reserve(count_map.size());
        for (const auto &[key, count] : count_map) {
            ret.emplace_back(key, std::to_string(count));
        }
        return ret;
    }

//
// The reduce function is called once for each key generated by the
// map tasks, with a list of all the values created for that key by
// any map task.
//
    std::string Reduce(const std::string &key, const std::vector<std::string> &values) {
        // Your code goes here
        // Hints: return the number of occurrences of the word.
        //  std::string ret = "0";
        int count = 0;
        for (const auto &value : values) {
            count += std::stoi(value);
        }
        return std::to_string(count);
    }
}  // namespace mapReduce